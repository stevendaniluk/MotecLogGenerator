#!/usr/bin/env python3

import argparse
import cantools
import os

from data_log import DataLog
from motec_log import MotecLog

DESCRIPTION = """Generates MoTeC .ld files from external log files generated by: CAN bus dumps, CSV
 files, or COBB Accessport CSV files"""

EPILOG = """The CAN bus log must be the same format as what is generated by 'candump' with the '-l'
option from the linux package can-utils. A MoTeC channel will be created for every signal in the
DBC file that has messages in the CAN log. The signal name and units will be directly copied from
the DBC file.

CSV files must have time as their first column. A MoTeC channel will be generated for all remaining
columns. All channels will not have any units assigned.

COBB Accessport CSV logs are simply generated by starting a logging session on the accessport. A
MoTeC channel will be created for every channel logged, the name and units will be directly copied
over.
"""

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG)
    parser.add_argument("log", type=str, help="Path to logfile")
    parser.add_argument("log_type", type=str, help="Type of log to process", \
        choices=["CAN", "CSV", "ACCESSPORT"])

    parser.add_argument("--output", type=str, \
        help="Name of output file, defaults to the same filename as 'log'")
    parser.add_argument("--frequency", type=float, default=20.0, \
        help="Fixed frequency to resample all channels at")
    parser.add_argument("--dbc", type=str, help="Path to DBC file, required if log type CAN")

    parser.add_argument("--driver", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--vehicle_id", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--vehicle_weight", type=int, default=0, help="Motec log metadata field")
    parser.add_argument("--vehicle_type", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--vehicle_comment", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--venue_name", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--event_name", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--event_session", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--long_comment", type=str, default="", help="Motec log metadata field")
    parser.add_argument("--short_comment", type=str, default="", help="Motec log metadata field")
    args = parser.parse_args()

    if args.log:
        args.log = os.path.expanduser(args.log)
    if args.dbc:
        args.dbc = os.path.expanduser(args.dbc)
    if args.output:
        args.output = os.path.expanduser(args.output)

    # Make sure our input files are valid
    if not os.path.isfile(args.log):
        print("ERROR: log file %s does not exist" % args.log)
        exit(1)

    if args.log_type == "CAN" and not os.path.isfile(args.dbc):
        print("ERROR: DBC file %s does not exist" % args.dbc)
        exit(1)

    print("Loading log...")
    with open(args.log, "r") as file:
        lines = file.readlines()

    # Create our data log from the input data
    data_log = DataLog()

    if args.log_type == "CAN":
        if not os.path.isfile(args.dbc):
            print("ERROR: DBC file %s does not exist" % args.dbc)
            exit(1)

        # Load the databse and log file
        print("Loading DBC...")
        can_db = cantools.database.load_file(args.dbc)

        print("Extracting data...")
        data_log.from_can_log(lines, can_db)
    elif args.log_type == "CSV":
        print("Extracting data...")
        data_log.from_csv_log(lines)
    elif args.log_type == "ACCESSPORT":
        print("Extracting data...")
        data_log.from_accessport_log(lines)

    if not data_log.channels:
        print("ERROR: Failed to find any channels in log data")
        exit(1)

    print("Parsed %.1fs log with %s channels:" % (data_log.duration(), len(data_log.channels)))
    for channel_name, channel in data_log.channels.items():
        print("\t%s" % channel)

    # Resample all the channels to occur at a fixed frequency. We must do this because the data in
    # motec log expects a constant sample rate, it does not associate a timestamp to each individual
    # message in a channel.
    data_log.resample(args.frequency)

    print("Converting to MoTeC log...")

    motec_log = MotecLog()
    motec_log.driver = args.driver
    motec_log.vehicle_id = args.vehicle_id
    motec_log.vehicle_weight = args.vehicle_weight
    motec_log.vehicle_type = args.vehicle_type
    motec_log.vehicle_comment = args.vehicle_comment
    motec_log.venue_name = args.venue_name
    motec_log.event_name = args.event_name
    motec_log.event_session = args.event_session
    motec_log.long_comment = args.long_comment
    motec_log.short_comment = args.short_comment

    motec_log.initialize()
    motec_log.add_all_channels(data_log)

    print("Saving MoTeC log...")
    if args.output:
        ld_filename = os.path.splitext(args.output)[0] + ".ld"
    else:
        # Copy the path and name from the source file, but change the extension
        candump_dir, candump_filename = os.path.split(args.log)
        candump_filename = os.path.splitext(candump_filename)[0]
        ld_filename = os.path.join(candump_dir, candump_filename + ".ld")

    output_dir = os.path.dirname(ld_filename)
    if output_dir and not os.path.isdir(output_dir):
        print("Directory '%s' does not exist, will create it" % output_dir)
        os.makedirs(output_dir)

    motec_log.write(ld_filename)
    print("Done!")
